#! /bin/bash
#
# Script to run unittests, or any other command, and notify
# user using the OS notification mechanism
#
# Usage:
#   unittest-notifier [options] command ...
#
# All arguments will be considered the command to run
#

# Where's the source? The default icons are there...
SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
  DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE" # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
done
DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"

# Select notifier mechanism depending on availability
if command -v terminal-notifier2 2>/dev/null ; then
    mechanism=terminal-notifier
    notifier=terminal-notifier
elif command -v /Applications/terminal-notifier.app/Contents/MacOS/terminal-notifier 2>/dev/null ; then
    mechanism=terminal-notifier
    notifier=/Applications/terminal-notifier.app/Contents/MacOS/terminal-notifier
elif command -v notify-send 2>/dev/null ; then
    mechanism=notify-send
    notifier=notify-send
fi

# If no known mechanism available, give hints depending on OS
if [ "$mechanism" = "" ] ; then
    echo "ERROR: No known mechanism for notifications found."
    os=`uname -s`
    if [ "$os" = "Darwin" ] ; then
        echo "Install 'terminal-notifier' from https://github.com/julienXX/terminal-notifier or via Brew/MacPorts"
    elif [ "$os" = "Linux" ] ; then
	echo "'notify-send' should be available for Linux. Try 'sudo <pkgmgr> install notify-send'."
    else
        echo "No idea how to create nice notifications in this OS..."
        echo "Please suggest a mechanism at https://github.com/thoni56/unittest-notifier"
    fi
    exit 1
fi

# Set up options for icons depending on mechanism
case $mechanism in
    terminal-notifier)
        title_prefix=-title
        message_prefix=-message
        app_icon_prefix=-appIcon
        icon_prefix=-contentImage
        ;;
    notify-send)
	title_prefix=
	message_prefix=
	icon_prefix=-i
	;;
    *)
        echo "Unknown notifier mechanism. Exiting..."
        exit
esac

# Set default values for most options
title_text="Unittests"
start_text="Starting..."
passed_text="Passed"
failed_text="Failed"
app_icon="$DIR"/cgreen-icon.png
start_icon="$DIR"/icon-start.png
passed_icon="$DIR"/icon-passed.png
failed_icon="$DIR"/icon-failed.png

# Handle options
while getopts ":t:" opt; do
    case $opt in
        t)
            # Title
            echo $OPTARG
            title_text="$OPTARG"
            shift 2
            ;;
        \?)
            echo "ERROR: Invalid option -$OPTARG" >&2
            exit 1
            ;;
        :)
            echo "ERROR: Option -$OPTARG requires an argument." >&2
            exit 1
            ;;
    esac
done

# Is there a command?
if test "$#" -eq 0; then
    echo "ERROR: expecting a command to run"
    echo
    echo "Usage: $0 <options> <command>"
    echo
    echo "Currently there are no options available."
    echo "All arguments that are not options, will be the command line that is run."
    exit
fi

# Assemble all notifier options
title="$title_prefix $title_text"
start="$message_prefix $start_text $icon_prefix $start_icon"
passed="$message_prefix $passed_text $icon_prefix $passed_icon"
failed="$message_prefix $failed_text $icon_prefix $failed_icon"

# Debug by uncommenting this
#notifier=/bin/echo

# Indicate start
$notifier $title $start

# Run the command
${@:1}
status=$?

# Indicate pass or fail depending on exit code
if [ $mechanism = "notify-send" ] ; then
    # Stock notify-send can't replace notification so kill all...
    killall notify-osd
fi
if [ $status ] ; then
    $notifier $title $passed
else
    $notifier $title $failed
fi
