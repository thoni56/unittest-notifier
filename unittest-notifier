#! /bin/sh -l
#
# Script to run unittests, or any other command, and notify
# user using the OS notification mechanism
#
# Usage:
#   unittest-notifier [options] command ...
#
# All arguments will be considered the command to run
#

# Where's the source? The default icons are there...
SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
  DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE" # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
done
DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"

# Select notifier mechanism depending on availability
if command -v terminal-notifier2 2>/dev/null ; then
    mechanism=terminal-notifier
    notifier=terminal-notifier
elif command -v /Applications/terminal-notifier.app/Contents/MacOS/terminal-notifier 2>/dev/null ; then
    mechanism=terminal-notifier
    notifier=/Applications/terminal-notifier.app/Contents/MacOS/terminal-notifier
fi

# If no known mechanism available, give hints depending on OS
if [ "$mechanism" = "" ] ; then
    echo "ERROR: No known mechanism for notifications found."
    os=`uname -s`
    if [ "$os" = "Darwin" ] ; then
        echo "Install terminal-notifier from https://github.com/julienXX/terminal-notifier or via Brew/MacPorts"
    else
        echo "No idea how to create nice notifications in this OS..."
        echo "Please suggest a mechanism at https://github.com/thoni56/unittest-notifier"
    fi
    exit 1
fi

# Set up options for icons depending on mechanism
case $mechanism in
    terminal-notifier)
        title_prefix=-title
        message_prefix=-message
        app_icon_prefix=-appIcon
        icon_prefix=-contentImage
        ;;
    *)
        echo "Unknown notifier mechanism. Exiting..."
        exit
esac

# Set default values for most options
title_text="Unittests"
start_text="Starting..."
passed_text="Passed"
failed_text="Failed"
app_icon="$DIR"/cgreen-icon.png
start_icon="$DIR"/icon-start.png
passed_icon="$DIR"/icon-passed.png
failed_icon="$DIR"/icon-failed.png

# Handle options
while getopts ":t:" opt; do
    case $opt in
        t)
            # Title
            echo $OPTARG
            title_text="\"$OPTARG\""
            shift 2
            ;;
        \?)
            echo "ERROR: Invalid option -$OPTARG" >&2
            exit 1
            ;;
        :)
            echo "ERROR: Option -$OPTARG requires an argument." >&2
            exit 1
            ;;
    esac
done

# Is there a command?
if test "$#" -eq 0; then
    echo "ERROR: expecting a command to run"
    echo
    echo "Usage: $0 <options> <command>"
    echo
    echo "Currently there are no options available."
    echo "All arguments that are not options, will be the command line that is run."
    exit
fi

# Assemble all notifier options
title="$title_prefix \"$title_text\""
start="$message_prefix $start_text $icon_prefix $start_icon"
passed="$message_prefix $passed_text $icon_prefix $passed_icon"
failed="$message_prefix $failed_text $icon_prefix $failed_icon"

# Debug by uncommenting this
#notifier=/bin/echo

# Indicate start
$notifier $title $start

# Run the command and indicate pass or fail depending on exit code
if ${@:1} ; then
    $notifier $title $passed
else
    $notifier $title $failed
fi
